<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" x="10" y="10"><statement name="HANDLER"><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum segment{" line1="    dp = 0b10000000," line2="    g  = 0b01000000," line3="    f  = 0b00100000," line4="    e  = 0b00010000," line5="    d  = 0b00001000," line6="    c  = 0b00000100," line7="    b  = 0b00000010," line8="    a  = 0b00000001" line9="}" numlines="10"></mutation><next><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum OnOff {" line1="    On  = 1," line2="    Off = 0" line3="}" numlines="4"></mutation><next><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum RgbLedPin {" line1="    R_Pin = 0," line2="    G_Pin = 1," line3="    B_Pin = 12" line4="}" numlines="5"></mutation><next><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Humiture {" line1="    Temperature = 0," line2="    Humidity = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Veer {" line1="    CW = 0," line2="    CCW = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Multi_platform {" line1="    // They correspond to 4-bit digital tube and can control 8 digital sections of the code tube." line2="    // default = 0xff, bit: on = 0, off = 1" line3="    // D7  D6  D5  D4  D3  D2  D1  D0" line4="    // DP  G   F   E   D   C   B   A" line5="    const DisReg0 = 0x00;" line6="    const DisReg1 = 0x01;" line7="    const DisReg2 = 0x02;" line8="    const DisReg3 = 0x03;" line9="" line10="    // The user can input the value and get the digital display directly." line11="    // D7  D6  D5  D4  D3  D2  D1  D0" line12="    // A3  A2  A1  A0  d3  d2  d1  d0" line13="    // A3:A0 controls which digit bits are displayed." line14="    // d3:d0 = 0---F" line15="    const DecReg = 0x1B;" line16="" line17="    // Realize display control in unit of segment" line18="    //    DP   G   F   E   D   C   B   A" line19="    // 0  07   06  05  04  03  02  01  00" line20="    // 1  0F   0F  0D  0C  0B  0A  09  08   " line21="    // 2  17   16  15  14  13  12  11  10" line22="    // 3  1F   1E  1D  1C  1B  1A  19  18" line23="    // data format:" line24="    // D7  D6  D5  D4  D3  D2  D1  D0" line25="    // Seg A6  A5  A4  A3  A2  A1  A0" line26="    // A5:A0 = data address, Seg = 0 = on, Seg = 1 = off  " line27="    const SegAddReg = 0x1C;" line28="" line29="    // Clear the screen or light up all leds." line30="    const GloReg = 0x1D;" line31="" line32="    function BC7278_spi_read_data(addr:number, dat:number) {" line33="        let data: number = (addr &lt;&lt; 8) + dat;" line34="        data = pins.spiWrite(data);" line35="        return data;" line36="    }" line37="" line38="    function BC7278_spi_write_data(addr: number, dat: number) {" line39="        let data2: number = (addr &lt;&lt; 8) + dat;" line40="        pins.spiWrite(data2);" line41="    }" line42="" line43="    ////////////////////////////////////////////" line44="    // display segment" line45="    // Seg   DP    G    F    E    D    C    B    A" line46="    // Bit " line47="    //  0    7h    6h   5h   4h   3h   2h   1h   0h" line48="    //  1    fh    eh   dh   ch   bh   ah   9h   8h" line49="    //  2    17h   16h  15h  14h  13h  12h  11h  10h" line50="    //  3    1fh   1eh  1dh  1ch  1bh  1ah  19h  18h" line51="    //  " line52="    // OnOff = 1 = on, OnOff = 0 = off" line53="    function SetDisplaySeg(Seg: number, OnOff: number){" line54="        if (OnOff != 0 &amp;&amp; OnOff != 1)" line55="            return;" line56="        Seg = ((~OnOff) &lt;&lt; 7) + Seg;" line57="        BC7278_spi_write_data(SegAddReg, Seg);" line58="    }" line59="" line60="    /////////////////////////////////////////////////////" line61="    //% block=&quot;Digital-Tube-Button_Init&quot;" line62="    //% group=&quot;Digital-Tube_Button&quot; weight=7" line63="    export function Digital_Tube_Button_Init() {" line64="        pins.spiPins(15, 14, 13);" line65="        pins.spiFormat(8, 3);" line66="        pins.spiFrequency(60000);" line67="    }" line68="" line69="    ////////////////////////////////////////////" line70="    //% block=&quot;Button_Interrupt-pin&quot;" line71="    //% group=&quot;Digital-Tube_Button&quot; weight=6" line72="    export function Buton_pin() {" line73="        return 11;" line74="    }" line75="" line76="    ////////////////////////////////////////////" line77="    //            bit: 0 0 0  x x x x x" line78="    // Read key value: 0 0 0 OK U D L R" line79="    // x = 1, There's no button to press. " line80="    // x = 0, There are buttons to press." line81="    //% block=&quot;Button&quot;" line82="    //% group=&quot;Digital-Tube_Button&quot; weight=6" line83="    export function Read_button(DG: number, Dat: number) {" line84="        // 0xff: pseudoinstruction" line85="        // Gets 16 key values" line86="        let AllKey: number = BC7278_spi_read_data(0xff, 0xff);" line87="        // Serial.println(AllKey, HEX);" line88="" line89="        // After processing data, obtain the key values of S12-S15." line90="        let keyValue: number = (~AllKey) &gt;&gt; 11;" line91="        // Serial.println(keyValue, HEX);" line92="" line93="        return keyValue;" line94="    }" line95="" line96="    /////////////////////////////////////////////////////" line97="    //% block=&quot;Digital-Tube_Clear&quot;" line98="    //% group=&quot;Digital-Tube_Button&quot; weight=5" line99="    export function Digital_Tube_Clear() {" line100="        BC7278_spi_write_data(GloReg, 0xff);" line101="    }" line102="" line103="    ////////////////////////////////////////////" line104="    // display: 0-9999 or 0.0-999.9" line105="    //% block=&quot;Digital-Tube_Num: $num&quot;" line106="    //% group=&quot;Digital-Tube_Button&quot; weight=4" line107="    export function DisplayNumber(num: number) {" line108="        let dat: number = 0;" line109="        let i_f: number = 0;" line110="        if (parseInt(num.toString()) == parseFloat(num.toString())) {  //integer" line111="            i_f = 0;" line112="            SetDisplaySeg(0x17, 0);           // Turn off the decimal point." line113="        }" line114="        else{                                                          //flaot" line115="            i_f = 1;" line116="            dat = ~~(num*10);" line117="            SetDisplaySeg(0x17, 1);           // Turn on the decimal point." line118="        }" line119="" line120="        //Digital_Tube_Seg(0x17, 0);          // Turn off the decimal point." line121="        if (dat / 1000 != 0) {" line122="            Digital_Tube_Num(0, dat / 1000);" line123="            Digital_Tube_Num(1, dat % 1000 / 100);" line124="            Digital_Tube_Num(2, dat % 100 / 10);" line125="            Digital_Tube_Num(3, dat % 10);" line126="            return;" line127="        }" line128="        if (dat % 1000 / 100 != 0) {" line129="            Digital_Tube_Seg(0, 0xff);" line130="            Digital_Tube_Num(1, dat % 1000 / 100);" line131="            Digital_Tube_Num(2, dat % 100 / 10);" line132="            Digital_Tube_Num(3, dat % 10);" line133="            return;" line134="        }" line135="" line136="        if (i_f == 0){" line137="            if (dat % 1000 / 10 != 0) {" line138="                Digital_Tube_Seg(0, 0xff);" line139="                Digital_Tube_Seg(1, 0xff);" line140="                Digital_Tube_Num(2, dat % 100 / 10);" line141="                Digital_Tube_Num(3, dat % 10);" line142="                return;" line143="            }" line144="            Digital_Tube_Seg(0, 0xff);" line145="            Digital_Tube_Seg(1, 0xff);" line146="            Digital_Tube_Seg(2, 0xff);" line147="            Digital_Tube_Num(3, dat % 10);" line148="        }" line149="        else{" line150="            Digital_Tube_Seg(0, 0xff);" line151="            Digital_Tube_Seg(1, 0xff);" line152="            Digital_Tube_Num(2, dat % 100 / 10);" line153="            Digital_Tube_Num(3, dat % 10);" line154="        }" line155="    }" line156="" line157="    ////////////////////////////////////////////" line158="    // display: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,  b,  C,  d,  E,  F" line159="    // Number : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15" line160="    // Position : 0, 1, 2, 3" line161="    //% block=&quot;Digital-Tube_Num: position $Position num $Number&quot;" line162="    //% Position.min=0 Position.max=3 Number.min=0 Number.max=15" line163="    //% group=&quot;Digital-Tube_Button&quot; weight=3" line164="    export function Digital_Tube_Num(Position: number, Number: number) {" line165="        if (Position &gt; 3 || Number &gt; 15)" line166="            return;" line167="        let dat2: number = 0;" line168="        dat2 = (Position &lt;&lt; 4) | Number;" line169="        BC7278_spi_write_data(DecReg, dat2);" line170="    }" line171="" line172="    ////////////////////////////////////////////" line173="    // segment" line174="    // Seg = xxxxxxxx = DP, G, F, E, D, C, B, A (x=0=on, x=1=off)" line175="    //% block=&quot;Segment: $Seg&quot;" line176="    //% group=&quot;Digital-Tube_Button&quot; weight=2" line177="    export function Segment(Seg: segment) {" line178="        return Seg;" line179="    }" line180="" line181="    ////////////////////////////////////////////" line182="    // display segment" line183="    // Position: 0--3" line184="    // Seg = xxxxxxxx = DP, G, F, E, D, C, B, A (x=0=on, x=1=off)" line185="    //% block=&quot;Digital-Tube_Seg: position $Position segment $Seg&quot;" line186="    //% Position.min=0 Position.max=3" line187="    //% group=&quot;Digital-Tube_Button&quot; weight=1" line188="    export function Digital_Tube_Seg(Position: number, Seg: number) {" line189="        let addr: number = 0;" line190="        switch (Position) {" line191="            case 0: addr = DisReg0; break;" line192="            case 1: addr = DisReg1; break;" line193="            case 2: addr = DisReg2; break;" line194="            case 3: addr = DisReg3; break;" line195="            default: return;" line196="        }" line197="        BC7278_spi_write_data(addr, Seg);" line198="    }" line199="" line200="" line201="" line202="    const LSBFIRST: number = 1;" line203="    const MSBFIRST: number = 0;" line204="    let ledData: number = 0;" line205="" line206="    //////////////////////////////////////////////////////////////" line207="    // Send 8-bit data to 74HC595." line208="    // bitOrder: MSBFIRST or LSBFIRST" line209="    function ShiftOut(bitOrder: number, val: number){" line210="        let i: number;" line211="        for (i = 0; i &lt; 8; i++) {" line212="            if (bitOrder == LSBFIRST) {" line213="                pins.digitalWritePin(16, val &amp; 1);" line214="                val &gt;&gt;= 1;" line215="            } else {" line216="                pins.digitalWritePin(16, val &amp; 128);" line217="                val &lt;&lt;= 1;" line218="            }" line219="            pins.digitalWritePin(8, 1);" line220="            control.waitMicros(10);" line221="            pins.digitalWritePin(8, 0);" line222="            control.waitMicros(10);" line223="        }" line224="    }" line225="" line226="    ////////////////////////////////////////////" line227="    //% block=&quot;$Onoff&quot;" line228="    //% group=&quot;Led&quot; weight=2" line229="    export function On_Off(Onoff: OnOff) {" line230="        return Onoff;" line231="    }" line232="" line233="    ////////////////////////////////////////////" line234="    // LED" line235="    //% block=&quot;Set $Pos led  $OnOff&quot;" line236="    //% Pos.min=0 Pos.max=7 OnOff.min=0 OnOff.max=1" line237="    //% group=&quot;Led&quot; weight=1" line238="    export function Set_Led(Pos: number, OnOff: number){" line239="        if (Pos &gt; 8 || OnOff &gt; 1) {" line240="            return;" line241="        }" line242="        if (OnOff == 1) {" line243="            ledData = ledData | (1 &lt;&lt; Pos);" line244="        }" line245="        else {" line246="            ledData = ledData &amp; (~(1 &lt;&lt; Pos));" line247="        }" line248="        //ground latchPin and hold low for as long as you are transmitting" line249="        pins.digitalWritePin(9, 0);" line250="        ShiftOut(MSBFIRST, ledData);" line251="        //no longer needs to listen for information" line252="        pins.digitalWritePin(9, 1);" line253="    }" line254="" line255="" line256="" line257="    ////////////////////////////////////////////" line258="    //% block=&quot;$Pin&quot;" line259="    //% group=&quot;RGB_Led&quot; weight=1" line260="    export function RgbLed_pin(Pin: RgbLedPin) {" line261="        return Pin;" line262="    }" line263="" line264="" line265="" line266="    // AHT20 Register address&#9;&#9;" line267="    const reg1_ = 0x1b;" line268="    const reg2_ = 0x1c;" line269="    const reg3_ = 0x1e;" line270="    const ac_   = 0xac;" line271="    const ac_d1 = 0x33;" line272="    const ac_d2 = 0x00;" line273="    const aht20Addr = 0x38;" line274="    let ct = [0, 0];" line275="" line276="    ////////////////////////////////////////////" line277="    function SendAC(){" line278="        pins.i2cWriteNumber(aht20Addr, ac_, NumberFormat.Int8LE, true);" line279="        pins.i2cWriteNumber(aht20Addr, ac_d1, NumberFormat.Int8LE, true);" line280="        pins.i2cWriteNumber(aht20Addr, ac_d2, NumberFormat.Int8LE, false);" line281="    }" line282="" line283="    ////////////////////////////////////////////" line284="    function Reset_REG(reg: number){" line285="        let  Byte = [ 0, 0, 0];" line286="" line287="        pins.i2cWriteNumber(aht20Addr, reg, NumberFormat.Int8LE, true);" line288="        pins.i2cWriteNumber(aht20Addr, 0x00, NumberFormat.Int8LE, true);" line289="        pins.i2cWriteNumber(aht20Addr, 0x00, NumberFormat.Int8LE, false);" line290="" line291="        basic.pause(5);" line292="        Byte[0] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line293="        Byte[1] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line294="        Byte[2] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, false);" line295="" line296="        basic.pause(10);" line297="        pins.i2cWriteNumber(aht20Addr, 0xb0 | reg, NumberFormat.Int8LE, true);" line298="        pins.i2cWriteNumber(aht20Addr, Byte[1], NumberFormat.Int8LE, true);" line299="        pins.i2cWriteNumber(aht20Addr, Byte[2], NumberFormat.Int8LE, false);" line300="    }" line301="" line302="    ////////////////////////////////////////////" line303="    function Read_Status(){" line304="        let stat;" line305="        stat = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, false);" line306="        return stat;" line307="    }" line308="" line309="    ////////////////////////////////////////////" line310="    //% block=&quot;Humiture_init&quot;" line311="    //% group=&quot;Humiture&quot; weight=3" line312="    ////////////////////////////////////////////" line313="    export function AHT20_Init(){" line314="        Reset_REG(reg1_);" line315="        Reset_REG(reg2_);" line316="        Reset_REG(reg3_);" line317="    }" line318="" line319="    ///////////////////////////////////////////" line320="    //No CRC check, read AHT20 temperature and humidity data directly" line321="    //% block=&quot;Read_humiture&quot;" line322="    //% group=&quot;Humiture&quot; weight=2" line323="    export function Read_CTdata(){" line324="        let  Byte = [0, 0, 0, 0, 0, 0];" line325="        let  RetuData = 0;" line326="        let  cnt = 0;" line327="" line328="        SendAC();                // Send the AC command to AHT20" line329="        basic.pause(80);" line330="" line331="        //Until bit[7] is 0, indicating idle state. If it is 1, indicating busy state" line332="        while (((Read_Status() &amp; 0x80) == 0x80)) {" line333="            basic.pause(2);" line334="            if (cnt++ &gt;= 100) {" line335="                return false;" line336="            }" line337="        }" line338="        Byte[0] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line339="        Byte[1] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line340="        Byte[2] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line341="        Byte[3] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line342="        Byte[4] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line343="        Byte[5] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, false);" line344="" line345="        // Byte[0]  //Status word: the state is 0x98, indicating busy state, and bit[7] is 1.  The state is 0x1C, or 0x0C, or 0x08 is idle, and bit[7] is 0.  " line346="        // Byte[1]  //humidity " line347="        // Byte[2]  //humidity " line348="        // Byte[3]  //humidity / temperature" line349="        // Byte[4]  //temperature " line350="        // Byte[5]  //temperature " line351="        RetuData = (RetuData | Byte[1]) &lt;&lt; 8;" line352="        RetuData = (RetuData | Byte[2]) &lt;&lt; 8;" line353="        RetuData = (RetuData | Byte[3]);" line354="        RetuData = RetuData &gt;&gt; 4;" line355="        ct[0] = RetuData * 100 / 1024 / 1024;           //humidity " line356="        RetuData = 0;" line357="        RetuData = (RetuData | Byte[3]) &lt;&lt; 8;" line358="        RetuData = (RetuData | Byte[4]) &lt;&lt; 8;" line359="        RetuData = (RetuData | Byte[5]);" line360="        RetuData = RetuData &amp; 0xfffff;" line361="        ct[1] = RetuData * 200 / 1024 / 1024 - 50;        //temperature " line362="        return true;" line363="    }" line364="" line365="    ////////////////////////////////////////////" line366="    //% block=&quot;$TH&quot;" line367="    //% group=&quot;Humiture&quot; weight=1" line368="    ////////////////////////////////////////////" line369="    export function Humiture_data(TH: Humiture) {" line370="        if (TH == Humiture.Humidity){" line371="            return ct[0];" line372="        }" line373="        else{" line374="            return ct[1];" line375="        }" line376="    }" line377="" line378="" line379="" line380="    ////////////////////////////////////////////" line381="    //% block=&quot;Ultrasonic(cm)&quot;" line382="    //% group=&quot;Ultrasonic&quot; weight=1" line383="    ////////////////////////////////////////////" line384="    export function Ultrasonic_(TH: Humiture) {" line385="        let t: number = 0;" line386="" line387="        pins.digitalWritePin(0, 1);" line388="        control.waitMicros(10);" line389="        pins.digitalWritePin(0, 0);" line390="" line391="        t = pins.pulseIn(DigitalPin.P1, PulseValue.High);" line392="        return t/29/2;" line393="    }" line394="" line395="" line396="" line397="    ////////////////////////////////////////////" line398="    //% block=&quot;Fan $_Veer speed $Speed&quot;" line399="    //% Speed.min=0 Speed.max=1023" line400="    //% group=&quot;Fan&quot; weight=1" line401="    ////////////////////////////////////////////" line402="    export function Fan_(_Veer: Veer, Speed: number) {" line403="        if (_Veer == Veer.CW){" line404="            pins.digitalWritePin(0, 0);" line405="            pins.analogWritePin(1, Speed)" line406="        }" line407="        else{" line408="            pins.analogWritePin(0, Speed)" line409="            pins.digitalWritePin(1, 0);" line410="        }" line411="    }" line412="" line413="" line414="    ////////////////////////////////////////////" line415="    //% block=&quot;Buzzer_Pin&quot;" line416="    //% group=&quot;Buzzer&quot; weight=1" line417="    export function Buzzer_pin() {" line418="        return 3;" line419="    }" line420="" line421="" line422="    ////////////////////////////////////////////" line423="    //% block=&quot;Button_Pin&quot;" line424="    //% group=&quot;Button&quot; weight=1" line425="    export function Button_pin() {" line426="        return 5;" line427="    }" line428="" line429="" line430="" line431="}" numlines="432"></mutation></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>